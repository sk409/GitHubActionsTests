name: Review
on:
  issue_comment:
    types: [created]
jobs:
  setup:
    if: contains(github.event.comment.html_url, '/pull/') && 
        github.event.comment.body == '/review'
    runs-on: ubuntu-latest
    outputs:
      branch: ${{ steps.pr.outputs.branch }}
      check_run_id: ${{ steps.check-run.outputs.result }}
    steps:
      - name: Notify
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              issue_number: ${{ github.event.issue.number }},
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: "自動レビューを開始しました。\n${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            })
      - name: Fetch branch
        id: pr
        run: |
          branch=$(curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" ${{ github.event.issue.pull_request.url }} | jq -r ".head.ref")
          echo "branch=$branch" >> $GITHUB_OUTPUT
      - name: Fetch check run id
        id: check-run
        uses: actions/github-script@v7
        with:
          result-encoding: string
          script: |
            const list = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: "${{ steps.pr.outputs.branch }}",
              check_name: "review",
              filter: "latest"
            });
            const checkRunID = list.data.check_runs[0].id;
            await github.rest.checks.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_run_id: checkRunID,
              status: "in_progress"
            })
            return checkRunID
  lint:
    runs-on: macos-14
    needs: [setup]
    steps:
      - name: Install swift-format
        run: brew install swift-format
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.setup.outputs.branch }}
      - name: Fetch base branch
        id: base
        run: |
          ref=$(curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" ${{ github.event.issue.pull_request.url }} | jq -r ".base.ref")
          echo "ref=$ref" >> $GITHUB_OUTPUT
          git fetch origin $ref
      - name: Lint
        run: |
          files=$(git diff --name-only --diff-filter=d origin/${{ steps.base.outputs.ref }}..${{ needs.setup.outputs.branch }} | grep .swift$)
          if [ -z $files ]; then
            exit 0
          fi
          swift-format lint -s "$fiiles"
  ut:
    runs-on: macos-14
    needs: [setup, lint]
    env:
      result_file_name: result.txt
      xcresult_path: ~/GitHubActionsTests.xcresult
    strategy:
      matrix:
        os: ["15.0", "16.0", "17.5", "macOS"]
    steps:
      - name: Delete Xcodes
        # Simulatorのインストールに使用するストレージを確保するため不要なXcodeを削除する。
        run: rm -rf /Applications/Xcode_16.1_beta.app
      - name: Select Xcode
        run: sudo xcode-select -s /Applications/Xcode_15.3.app/Contents/Developer
      - name: Install simulators
        if: ${{ (matrix.os == '15.0' || matrix.os == '16.0') && steps.simulators.outputs.cache-hit != 'true' }}
        run: sudo xcodes runtimes install --keep-archive "iOS ${{ matrix.os }}"
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.setup.outputs.branch }}
      - name: Cache packages
        uses: actions/cache@v4
        with:
          path: ~/SourcePackages
          key: SPM-${{ hashFiles('GitHubActions.xcworkspace/xcshareddata/swiftpm/Package.resolved') }}
      - name: UT
        id: ut
        continue-on-error: true
        run: |
          if [ ${{ matrix.os }} = "macOS" ]; then
            scheme=Mac-Tests
            destination="platform=macOS,arch=arm64,name=My Mac"
          else
            while [ -z "$device" ]; do
              sleep 0.5
              device=$(xcrun simctl list -j devices | jq -r --arg os "iOS-$(echo ${{ matrix.os }} | sed "s/\./-/")" '.devices | with_entries(select(.key | endswith($os)))[][0].name // empty' | tr -d "\n")
            done
            scheme=iOS-Tests
            destination="platform=iOS Simulator,name=$device,OS=${{ matrix.os }}"
          fi
          xcodebuild -workspace GitHubActions.xcworkspace \
                     -scheme $scheme \
                     -destination "$destination" \
                     -resultBundlePath ${{ env.xcresult_path }} \
                     -clonedSourcePackagesDirPath ~/SourcePackages \
                     -testLanguage ja \
                     -skipMacroValidation \
                     -skipPackagePluginValidation \
                     test
      - name: Write test result
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs")
            const path = require("path")
            fs.writeFileSync(path.join(process.env.HOME, "${{ env.result_file_name }}"), "${{ steps.ut.outcome }}")
      - name: Upload test result
        uses: actions/upload-artifact@v4
        with:
          name: result-${{ matrix.os }}
          path: ~/${{ env.result_file_name }}
          retention-days: 1
      - name: Upload xcresult
        uses: actions/upload-artifact@v4
        with:
          name: GitHubActionsTests-${{ matrix.os }}-${{ github.run_number }}.xcresult
          path: ${{ env.xcresult_path }}
          retention-days: 1
  completed:
    runs-on: ubuntu-latest
    # コメントが/review以外の場合はスキップする
    if: success() || failure()
    needs: [setup, lint, ut]
    steps:
      - name: Download test results
        uses: actions/download-artifact@v4
        with:
          path: ~/results
          pattern: result-*
      - name: Completed
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs")
            const path = require("path")
            
            var conclusion = ${{ needs.lint.result == 'success' }}

            if (conclusion) {
              const resultsPath = path.resolve(process.env.HOME, "results")
              const resultDirs = fs.readdirSync(resultsPath)
              if (resultDirs.length == 4) {
                for (const resultDir of resultDirs) {
                  const result = fs.readFileSync(path.join(resultsPath, resultDir, "result.txt"))
                  conclusion &&= result == "success"
                }
              } else {
                conclusion = false
              }
            }

            await github.rest.checks.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_run_id: ${{ needs.setup.outputs.check_run_id }},
              status: "completed",
              conclusion: conclusion ? "success" : "failure"
            })
    